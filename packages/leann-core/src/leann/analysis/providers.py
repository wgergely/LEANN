import os
import json
import subprocess
import logging
from pathlib import Path
from typing import Dict, List, Any, Optional, Type
from .base import BaseAnalysisProvider

logger = logging.getLogger(__name__)

class PythonTachProvider(BaseAnalysisProvider):
    """
    Python analysis provider powered by TACH.
    Handles automated bootstrapping and rich dependency extraction.
    """

    def __init__(self):
        self.project_root: Optional[Path] = None
        self.config_path: Optional[Path] = None
        self._dependency_map: Optional[Dict[str, List[str]]] = None
        self._reverse_map: Optional[Dict[str, List[str]]] = None
        self.is_bootstrapped = False

    def bootstrap(self, project_root: Path, force: bool = False) -> bool:
        """Initialize TACH for the project."""
        self.project_root = project_root.resolve()
        self.config_path = self.project_root / "tach.toml"

        if self.is_bootstrapped and not force:
            return True

        # Check if tach is available
        try:
            subprocess.run(["tach", "--version"], capture_output=True, check=True)
        except (subprocess.CalledProcessError, FileNotFoundError):
            logger.warning("TACH CLI not found. Python analysis will be heuristic-only.")
            return False

        try:
            # 1. Detect and Generate Config if missing
            if not self.config_path.exists() or force:
                roots = self._detect_source_roots()
                logger.info(f"Generating TACH config for {self.project_root} with roots {roots}...")
                self._generate_config(roots)
            
                self._sync()
            
            # 3. Clear existing maps to force reload on next access
            self._dependency_map = None
            self._reverse_map = None
            
            self.is_bootstrapped = True
            logger.info(f"TACH successfully bootstrapped for {self.project_root}")
            return True
        except Exception as e:
            logger.error(f"TACH bootstrapping failed for {self.project_root}: {e}")
            return False

    def _detect_source_roots(self) -> List[str]:
        """Heuristic to find Python source roots."""
        roots = []
        for candidate in ["src", "lib"]:
            if (self.project_root / candidate).exists():
                roots.append(candidate)
        
        # Top-level packages
        for item in self.project_root.iterdir():
            if item.is_dir() and item.name not in roots:
                if item.name.startswith(".") or item.name in ["tests", "__pycache__", "venv", ".venv", "dist", "build"]:
                    continue
                if (item / "__init__.py").exists():
                    roots.append(item.name)
        
        return roots if roots else ["."]

    def _generate_config(self, source_roots: List[str]):
        """Generate a tach.toml with granular sub-modules."""
        modules = []
        for root in source_roots:
            root_path = self.project_root / root
            if not root_path.exists() or not root_path.is_dir():
                continue
            for item in root_path.iterdir():
                if item.is_dir() and (item / "__init__.py").exists():
                    modules.append({
                        "path": str(item.relative_to(root_path)).replace("\\", "/"),
                        "depends_on": ["**"]
                    })
        
        if not modules:
            modules.append({"path": ".", "depends_on": ["**"]})

        config = [
            '# Auto-generated by leann-core',
            f'source_roots = {json.dumps(source_roots)}',
            'respect_gitignore = true',
            '',
        ]
        for mod in modules:
            config.append('[[modules]]')
            config.append(f'path = "{mod["path"]}"')
            config.append(f'depends_on = {json.dumps(mod["depends_on"])}')
            config.append('')

        with open(self.config_path, "w") as f:
            f.write("\n".join(config))

    def _sync(self):
        """Invoke tach sync."""
        subprocess.run(
            ["tach", "sync", "--add"],
            cwd=self.project_root,
            check=True,
            capture_output=True,
            text=True
        )

    def _run_map(self, direction: str = "dependencies") -> Dict[str, List[str]]:
        """Fetch dependency map from TACH."""
        try:
            result = subprocess.run(
                ["tach", "map", "--direction", direction],
                cwd=self.project_root,
                check=True,
                capture_output=True,
                text=True
            )
            data = json.loads(result.stdout)
            return {k.replace("\\", "/"): [p.replace("\\", "/") for p in v] for k, v in data.items()}
        except Exception:
            return {}

    def get_file_context(self, abs_file_path: Path) -> Dict[str, Any]:
        """Implementation of BaseAnalysisProvider.get_file_context."""
        if not self.is_bootstrapped or self.project_root is None:
            return {}

        try:
            rel_path = str(abs_file_path.relative_to(self.project_root)).replace("\\", "/")
        except ValueError:
            return {}

        # Load maps lazily
        if self._dependency_map is None:
            self._dependency_map = self._run_map("dependencies")
        if self._reverse_map is None:
            self._reverse_map = self._run_map("dependents")

        return {
            "dependencies": self._dependency_map.get(rel_path, []),
            "dependents": self._reverse_map.get(rel_path, []),
            "closure": self._get_closure(rel_path),
            "external": self._get_report(rel_path, "external"),
            "detailed_dependencies": self._get_report(rel_path, "dependencies"),
            "detailed_usages": self._get_report(rel_path, "usages")
        }

    def _get_closure(self, rel_path: str) -> List[str]:
        """Internal helper for transitive closure."""
        cli_path = rel_path.replace("/", os.sep)
        try:
            result = subprocess.run(
                ["tach", "map", "--closure", cli_path],
                cwd=self.project_root,
                check=True,
                capture_output=True,
                text=True
            )
            data = json.loads(result.stdout)
            if isinstance(data, dict):
                for val in data.values():
                    return [p.replace("\\", "/") for p in val]
            return [p.replace("\\", "/") for p in data]
        except Exception:
            return []

    def _get_report(self, rel_path: str, mode: str) -> List[str]:
        """Internal helper for tach report parsing."""
        cli_path = rel_path.replace("/", os.sep)
        args = ["tach", "report", f"--{mode}", cli_path]
        try:
            result = subprocess.run(
                args,
                cwd=self.project_root,
                capture_output=True,
                text=True
            )
            lines = []
            capture = False
            for line in result.stdout.splitlines():
                line = line.strip()
                if not line: continue
                if any(h in line for h in ["Dependencies of", "Usages of", "External Dependencies"]):
                    capture = True
                    continue
                if "---" in line or (line.startswith("[") and line.endswith("]")):
                    continue
                if capture:
                    if ":" in line or mode == "external":
                        lines.append(line)
            return lines
        except Exception:
            return []

    def get_project_summary(self) -> Dict[str, Any]:
        """Return Mermaid graph for the project."""
        try:
            subprocess.run(["tach", "show", "--mermaid"], cwd=self.project_root, capture_output=True, check=True)
            mmd = self.project_root / "tach_module_graph.mmd"
            return {"mermaid_graph": mmd.read_text() if mmd.exists() else ""}
        except Exception:
            return {}

# Registry management
_PROVIDER_REGISTRY: Dict[str, Type[BaseAnalysisProvider]] = {
    "python": PythonTachProvider,
}
_PROVIDER_CACHE: Dict[tuple[Path, str], BaseAnalysisProvider] = {}

def get_provider(language: str, project_root: Path) -> Optional[BaseAnalysisProvider]:
    """Get or create an analysis provider for the given language and project root."""
    lang = language.lower()
    if lang not in _PROVIDER_REGISTRY:
        return None

    project_root = project_root.resolve()
    cache_key = (project_root, lang)

    if cache_key not in _PROVIDER_CACHE:
        provider_cls = _PROVIDER_REGISTRY[lang]
        provider = provider_cls()
        if provider.bootstrap(project_root):
            _PROVIDER_CACHE[cache_key] = provider
        else:
            return None

    return _PROVIDER_CACHE[cache_key]
